## ۱) پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

وقتی داخل یک پوشه دستور git init یا وقتی git clone می‌کنید، این پوشه ساخته می‌شود و همه‌ی داده‌های مربوط به تاریخچه، پیکربندی و وضعیت داخلی مخزن را نگه می‌دارد.

**چه چیزهایی داخل .git هست؟**

- objects/ — تمام اشیاء گیت: blobها (محتوای فایل‌ها)، treeها (درخت فایل/پوشه)، و commitها.
- refs/ — اشاره‌گرها: شاخه‌ها (refs/heads/)، تگ‌ها (refs/tags/) و ریموت‌ها (refs/remotes/).
- HEAD — نشان‌دهنده‌ی شاخه یا commit فعلی.
- index — فایل stage یا همان staging area (فایل باینری که وضعیت staged را نگهداری می‌کند).
- config — تنظیمات محلی مخزن (میشود اینجا تنظیمات repo-specific را دید).
- logs/ — تاریخچه‌ی حرکت refs (مثلا reflog برای بازگردانی).
- hooks/ — اسکریپت‌هایی که موقع رویدادهای خاص اجرا می‌شوند (قبل از commit، قبل از push و...).

**با چه دستوری ساخته می‌شود؟**

```
git init
```

یا وقتی مخزن را از راه دور کپی می‌کنید:

```
git clone <url>
```
---
## ۲) منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

هنگامی که از واژه atomic برای یک عملیات استفاده می‌کنیم، یعنی یک عملیات یا کاملا اجرا می‌شود یا اصلا اجرا نمی‌شود. در **Atomic commit** هر commit در گیت یک واحد atomic تغییر است؛ یا کل تغییرات آن commit وارد تاریخچه می‌شود یا اصلا وارد نمی‌شود. در **Atomic pull-request** (یا merge از طریق PR) وقتی PR ادغام می‌شود، همه تغییرات آن PR به‌طور یکجا وارد شاخه‌ی هدف می‌شود یا اگر مشکلی (مثلا تست‌ها شکست بخورند) هست، هیچ‌کدام وارد نمی‌شوند. در سرویس‌هایی مثل GitHub/GitLab، عملیات merge معمولا به‌صورت atomic انجام می‌شود. هدف atomic بودن جلوگیری از حالات نیمه‌پایدار در کد شاخه‌ی اصلی و تسهیل بازگشت به وضعیت سالم است.

---

## ۳) تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick

- **git fetch**
  - فقط از ریموت داده‌ها را دانلود می‌کند (شاخه‌ها و commitها) و آن‌ها را در refs/remotes/<remote>/... به‌روزرسانی می‌کند.
  - تأثیری روی شاخه‌ی فعلی شما یا working tree ندارد.
  - وقتی می‌خواهید بررسی کنید چه تغییراتی در ریموت آمده، fetch امن‌ترین گزینه است.

برای مثال:

```
git fetch origin
```

- **git pull**
  - در واقع ترکیبی از git fetch و سپس ادغام تغییرات ریموت در شاخه‌ی فعلی است.
  - به طور پیش‌فرض pull معادل fetch + merge است، اما می‌توان آن را طوری تنظیم کرد که بعد از fetch عملیات rebase انجام شود (git pull --rebase).

برای مثال:

```
git pull origin main
git pull --rebase origin main
```

- **git merge**
  - دو شاخه (یا یک شاخه و یک commit) را کنار هم می‌آورد. اگر تاریخچه دچار جدا جدا نباشد، ممکن است یک commit ادغام (merge commit) بسازد.
  - تاریخچه باقی می‌ماند و نشان می‌دهد که شاخه‌ها کجا با هم ادغام شده‌اند.

برای مثال:

```
git merge feature-x
```

- **git rebase**
  - رویه‌ای که commitهای یک شاخه را برمی‌دارد و دوباره روی نوک شاخه‌ی دیگری می‌گذارد؛ نتیجه تاریخچه‌ای خطی‌تر است (بدون merge commit).

برای مثال:

```
git rebase main
```

- **git cherry-pick**
  - یک (یا چند) commit مشخص را انتخاب می‌کند و آن‌ها را روی شاخه‌ی فعلی تکرار می‌کند (یک commit جدید با همان تغییرات ساخته می‌شود، اما شناسه‌ی متفاوت).
  - مناسب وقتی می‌خواهید فقط یک اصلاح کوچک یا یک فیکس را از یک شاخه بردارید بدون ادغام کامل آن شاخه.

برای مثال:

```
git cherry-pick <commit-hash>
```
---

## ۴) تفاوت دستورهای reset و revert و restore و switch و checkout

- **git reset**
  - شاخه‌ی فعلی (pointer) را به یک commit دیگر می‌برد. حالت‌هایی دارد:
    - --soft فقط pointer شاخه را جابجا می‌کند (index و working tree بدون تغییر).
    - --mixed (پیش‌فرض) pointer را جابجا می‌کند و index را هم هماهنگ می‌کند، اما working tree تغییر نمی‌کند.
    - --hard pointer، index و working tree را به آن commit می‌برد (تغییرات محلی از بین می‌روند).

برای مثال:

```
git reset --soft HEAD~1   # یک commit به عقب، تغییرات در staged می‌ماند
git reset --mixed HEAD~1  # تغییرات از staged خارج می‌شود
git reset --hard HEAD~1   # همه چیز را به یک commit قبل برمی‌گرداند
```

- **git revert**
  - یک commit را معکوس می‌کند اما به شکلی امن: یک commit جدید می‌سازد که تغییرات commit منتخب را خنثی می‌کند.
  - این روش امن است برای بازگرداندن تغییرات در شاخه‌هایی که با دیگران به اشتراک گذاشته شده‌اند؛ چون تاریخچه را بازنویسی نمی‌کند.

برای مثال:

```
git revert <commit-hash>
```

- **git restore**
  - برای بازیابی فایل‌ها از index یا commit به working tree یا برعکس استفاده می‌شود.
  - جایگزین ایمن‌تری برای برخی استفاده‌های checkout است که گاهی گیج‌کننده بود.

برای مثال:

```
git restore file.txt
git restore --staged file.txt
```

- **git switch**
  - مخصوص عوض کردن شاخه‌ها است و جایگزینی واضح‌تر برای رفتار چندمنظوره‌ی checkout که هم روی فایل‌ها و هم روی شاخه‌ها اثر می‌گذاشت.

برای مثال:

```
git switch feature-x
git switch -c new-branch   # ساخت شاخه و رفتن به آن
```

- **git checkout**
  - دستور قدیمی که هم برای تغییر شاخه و هم برای بازیابی فایل‌ها استفاده می‌شد. به همین دلیل در نسخه‌های جدید گیت توصیه می‌شود از switch برای شاخه‌ها و restore برای فایل‌ها استفاده کنید تا سردرگمی کمتر شود.

برای مثال:

```
git checkout feature-x
git checkout -- file.txt   # بازیابی فایل از HEAD
```

---

## ۵) منظور از stage یا همان index چیست؟ دستور stash چه کاری انجام می‌دهد؟

- **Stage / Index**
  - وقتی فایل‌ها را تغییر می‌دهید، ابتدا در working directory تغییر می‌کنند. وقتی آماده شدید که این تغییرات را commit کنید، آن‌ها را به staging area می‌فرستید (معمولا با git add). فایل index داخل git/index وضعیت فایل‌های staged را نگهداری می‌کند.
  - Commit از محتوای index یک snapshot می‌سازد؛ یعنی چیزی که در commit می‌بینید دقیقا همان چیزی است که در index بوده.

برای مثال:

```
git add file.txt
git commit -m
```

- **git stash**
  - وقتی مشغول کار روی چیزی هستید ولی نمی‌خواهید تغییرات را commit کنید و هم‌زمان باید شاخه را تغییر دهید یا یک pull انجام دهید، git stash تغییرات working directory (و در صورت خواسته index) را ذخیره موقت می‌کند و working tree را تمیز می‌کند.
  - stash در پس‌زمینه یک commit موقت می‌سازَد و آن را در یک stack ذخیره می‌کند. بعدا می‌توانی آن را git stash apply یا git stash pop کنی تا تغییرات برگردند.

برای مثال:

```
git stash          # ذخیره و پاکسازی تغییرات
git stash apply    # اعمال کردن تغییرات ذخیره‌شده (بدون حذف از stash)
git stash pop      # اعمال و پاک‌کردن از stash
```

---

