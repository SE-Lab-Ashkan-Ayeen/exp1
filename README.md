## ۱) پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

وقتی داخل یک پوشه دستور git init یا وقتی git clone می‌کنید، این پوشه ساخته می‌شود و همه‌ی داده‌های مربوط به تاریخچه، پیکربندی و وضعیت داخلی مخزن را نگه می‌دارد.

**چه چیزهایی داخل .git هست؟**

- objects/ — تمام اشیاء گیت: blobها (محتوای فایل‌ها)، treeها (درخت فایل/پوشه)، و commitها.
- refs/ — اشاره‌گرها: شاخه‌ها (refs/heads/)، تگ‌ها (refs/tags/) و ریموت‌ها (refs/remotes/).
- HEAD — نشان‌دهنده‌ی شاخه یا commit فعلی.
- index — فایل stage یا همان staging area (فایل باینری که وضعیت staged را نگهداری می‌کند).
- config — تنظیمات محلی مخزن (میشود اینجا تنظیمات repo-specific را دید).
- logs/ — تاریخچه‌ی حرکت refs (مثلا reflog برای بازگردانی).
- hooks/ — اسکریپت‌هایی که موقع رویدادهای خاص اجرا می‌شوند (قبل از commit، قبل از push و...).

**با چه دستوری ساخته می‌شود؟**

```
git init
```

یا وقتی مخزن را از راه دور کپی می‌کنید:

```
git clone <url>
```
---
## ۲) منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

هنگامی که از واژه atomic برای یک عملیات استفاده می‌کنیم، یعنی یک عملیات یا کاملا اجرا می‌شود یا اصلا اجرا نمی‌شود. در **Atomic commit** هر commit در گیت یک واحد atomic تغییر است؛ یا کل تغییرات آن commit وارد تاریخچه می‌شود یا اصلا وارد نمی‌شود. در **Atomic pull-request** (یا merge از طریق PR) وقتی PR ادغام می‌شود، همه تغییرات آن PR به‌طور یکجا وارد شاخه‌ی هدف می‌شود یا اگر مشکلی (مثلا تست‌ها شکست بخورند) هست، هیچ‌کدام وارد نمی‌شوند. در سرویس‌هایی مثل GitHub/GitLab، عملیات merge معمولا به‌صورت atomic انجام می‌شود. هدف atomic بودن جلوگیری از حالات نیمه‌پایدار در کد شاخه‌ی اصلی و تسهیل بازگشت به وضعیت سالم است.

---

## ۳) تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick

- **git fetch**
  - فقط از ریموت داده‌ها را دانلود می‌کند (شاخه‌ها و commitها) و آن‌ها را در refs/remotes/<remote>/... به‌روزرسانی می‌کند.
  - تأثیری روی شاخه‌ی فعلی شما یا working tree ندارد.
  - وقتی می‌خواهید بررسی کنید چه تغییراتی در ریموت آمده، fetch امن‌ترین گزینه است.

برای مثال:

```
git fetch origin
```

- **git pull**
  - در واقع ترکیبی از git fetch و سپس ادغام تغییرات ریموت در شاخه‌ی فعلی است.
  - به طور پیش‌فرض pull معادل fetch + merge است، اما می‌توان آن را طوری تنظیم کرد که بعد از fetch عملیات rebase انجام شود (git pull --rebase).

برای مثال:

```
git pull origin main
git pull --rebase origin main
```

- **git merge**
  - دو شاخه (یا یک شاخه و یک commit) را کنار هم می‌آورد. اگر تاریخچه دچار جدا جدا نباشد، ممکن است یک commit ادغام (merge commit) بسازد.
  - تاریخچه باقی می‌ماند و نشان می‌دهد که شاخه‌ها کجا با هم ادغام شده‌اند.

برای مثال:

```
git merge feature-x
```

- **git rebase**
  - رویه‌ای که commitهای یک شاخه را برمی‌دارد و دوباره روی نوک شاخه‌ی دیگری می‌گذارد؛ نتیجه تاریخچه‌ای خطی‌تر است (بدون merge commit).

برای مثال:

```
git rebase main
```

- **git cherry-pick**
  - یک (یا چند) commit مشخص را انتخاب می‌کند و آن‌ها را روی شاخه‌ی فعلی تکرار می‌کند (یک commit جدید با همان تغییرات ساخته می‌شود، اما شناسه‌ی متفاوت).
  - مناسب وقتی می‌خواهید فقط یک اصلاح کوچک یا یک فیکس را از یک شاخه بردارید بدون ادغام کامل آن شاخه.

برای مثال:

```
git cherry-pick <commit-hash>
```
---


